<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lizard Visualizer - Live MIDI</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <button id="startButton">Start Visualizer</button>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let currentBaseHue = Math.floor(Math.random() * 360);
    let lastChordSignature = '';
    let gegoShapeNodes = [];
    let gegoShapeConnections = [];
    const sotoSolidTop = Math.random() < 0.5;

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }

    function rotate3D(x, y, z, angleX, angleY) {
      // Rotate around X axis
      let y1 = y * Math.cos(angleX) - z * Math.sin(angleX);
      let z1 = y * Math.sin(angleX) + z * Math.cos(angleX);
      // Rotate around Y axis
      let x1 = x * Math.cos(angleY) + z1 * Math.sin(angleY);
      let z2 = -x * Math.sin(angleY) + z1 * Math.cos(angleY);
      return [x1, y1, z2];
    }

    resize();
    window.addEventListener('resize', resize);

    const activeNotes = {
      lissajous: [],
      harmonograph: [],
      sphere: [],
      gegoNet: [],
      sinewave: [],
      triangle: [],
      moireCircles: [],
      gegoShape: [],
      sotoGrid: []
    };

    const SOTO_PALETTE = [
      '#EF4136', // Red-orange
      '#005BBB', // Blue
      '#FCEE09', // Yellow
      '#2E7D32', // Green
      '#FFFFFF', // White
      '#4A148C', // Purple
      '#8B0000', // Dark red
    ];

    const NOTE_ON = 0x90;
    const NOTE_OFF = 0x80;

    function pitchToColor(midi) {
      const hue = (midi % 12) * 30;
      return `hsla(${hue}, 100%, 70%, 0.6)`;
    }

    function drawLissajousComplex(t, notes) {
      if (notes.length === 0) return;
      const a = notes[0] % 7 + 1;
      const b = notes[1 % notes.length] % 7 + 1;
      const delta = (notes[2 % notes.length] || notes[0]) * 0.1;

      ctx.save();
      ctx.translate(width / 2, height / 2);
      ctx.rotate(Math.sin(t * 0.1) * 0.3);
      ctx.beginPath();
      for (let i = 0; i < Math.PI * 2; i += 0.01) {
        const x = Math.sin(a * i + delta + t * 0.5) * 250;
        const y = Math.sin(b * i + t * 0.3) * 250;
        ctx.lineTo(x, y);
      }
      ctx.strokeStyle = 'hsla(' + (a + b) * 20 + ', 100%, 60%, 0.5)';
      ctx.shadowColor = ctx.strokeStyle;
      ctx.shadowBlur = 25;
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    function drawOutlinedRotatingTriangle(x, y, size, angle, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, -size);
      ctx.lineTo(size * 0.866, size * 0.5);
      ctx.lineTo(-size * 0.866, size * 0.5);
      ctx.closePath();
      ctx.strokeStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 20;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    function drawHarmonographComplex(t, notes) {
      if (notes.length === 0) return;

      ctx.save();
      ctx.translate(width / 2, height / 2);

      notes.forEach((midi, idx) => {
        const seed = midi * 0.1;

        const velocity = (activeNotes.harmonograph.find(n => n.midi === midi)?.velocity || 0); // 0–1 range
        const velocityScale = 1 + velocity * 1.5; // scale up to 250% at full velocity

        const A1 = (100 + Math.sin(t * 0.3 + idx) * 50) * velocityScale;
        const A2 = (100 + Math.cos(t * 0.2 + idx * 2) * 50) * velocityScale;
        // const A1 = 100 + Math.sin(t * 0.3 + idx) * 50;
        // const A2 = 100 + Math.cos(t * 0.2 + idx * 2) * 50;
        const f1 = midi * 0.03 + 0.01 * Math.sin(t + idx);
        const f2 = midi * 0.025 + 0.01 * Math.cos(t + idx * 1.3);
        const p1 = idx * Math.PI / 4;
        const p2 = idx * Math.PI / 3;
        const d1 = 0.001 + 0.0005 * Math.sin(t * 0.5 + idx);
        const d2 = 0.001 + 0.0005 * Math.cos(t * 0.3 + idx);

        ctx.beginPath();
        for (let i = 0; i < 3000; i++) {
          const time = i * 0.002 + t * 0.2;
          const x = A1 * Math.sin(f1 * time + p1) * Math.exp(-d1 * time);
          const y = A2 * Math.sin(f2 * time + p2) * Math.exp(-d2 * time);
          ctx.lineTo(x, y);
        }

        const hue = (midi % 12) * 30;
        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.4)`;
        ctx.shadowColor = ctx.strokeStyle;
        ctx.shadowBlur = 25;
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      ctx.restore();
    }


    function drawNoteVisuals(notes, t, type = 'triangle', radiusScale = 1, spread = 300) {
      notes.forEach(({ midi, velocity, timestamp }) => {
        const progress = (t - timestamp) / 1000;
        if (progress > 2) return; // ignore older notes

        const angle = midi * 0.3 + progress * 2;
        const radius = radiusScale * (velocity + 0.5) * spread;

        const offsetX = width * 0.25;
        const offsetY = height * 0.25;

        const baseX = Math.cos(angle) * radius;
        const baseY = Math.sin(angle) * radius * 0.5;

        const x = baseX + offsetX;
        const y = baseY + offsetY;
        const color = pitchToColor(midi);

        if (type === 'triangle') {
          drawOutlinedRotatingTriangle(x, y, (20 + velocity * 12) * 2.5, t + midi * 0.2, color);
          drawOutlinedRotatingTriangle(width - x, height - y, (20 + velocity * 12) * 2.5, t + midi * 0.2, color);
        } else if (type === 'sinewave') {
          ctx.beginPath();
          ctx.strokeStyle = color;
          for (let i = -width / 2; i < width / 2; i += 5) {
            const frequency = 0.01 + midi * 0.0005;
            const yOffset = Math.sin((i + t * 100 + midi * 5) * frequency) * 40;
            ctx.lineTo(i + width / 2, yOffset + height / 2);
          }
          ctx.stroke();
        }
      });
    }

    function drawMoirePattern(t, notes) {
      if (notes.length === 0) return;

      const baseCount = 8;
      const spacing = 35;
      const speed = 0.0015;

      ctx.save();
      ctx.translate(width / 2, height / 2);

      notes.forEach((n, i) => {
        const midi = n.midi;
        const velocity = n.velocity || 0.5;
        const angleOffset = Math.sin(t * speed * (i + 1)) * 0.4;
        const circleCount = baseCount + Math.floor((midi % 6) * 1.5);
        const sizeMultiplier = 1 + velocity * 1.5;
        const hue = (midi % 12) * 30;

        ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.15)`;
        ctx.shadowColor = `hsla(${hue}, 100%, 70%, 0.8)`;
        ctx.shadowBlur = 15;
        ctx.lineWidth = 1;

        for (let j = 0; j < circleCount; j++) {
          const radius = j * spacing * sizeMultiplier;
          ctx.beginPath();
          for (let a = 0; a < Math.PI * 2; a += 0.2) {
            const x = radius * Math.cos(a + angleOffset * j);
            const y = radius * Math.sin(a + angleOffset * j);
            if (j === 0 && a === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }
      });

      ctx.restore();
    }

    function drawWireSphere(t, notes) {
      if (notes.length === 0) return;

      ctx.save();
      ctx.translate(width / 2, height / 2);

      const baseRadius = 160;
      const latLines = 12;
      const lonLines = 20;

      const velocityAvg = notes.reduce((acc, n) => acc + n.velocity, 0) / notes.length;
      const sizeFactor = 1 + velocityAvg * 0.8;
      const radius = baseRadius * sizeFactor;

      const chordSize = notes.length;
      const deformAmount = Math.min((chordSize - 1) / 9, 1) * 1.2;

      // Create a unique signature of active MIDI notes
      const chordSig = notes.map(n => n.midi).sort().join('-');

      if (chordSig !== lastChordSignature) {
        lastChordSignature = chordSig;
        currentBaseHue = Math.floor(Math.random() * 360);
      }

      const hue = (currentBaseHue + chordSize * 20 + t * 5) % 360;

      ctx.strokeStyle = `hsla(${hue}, 100%, 65%, 0.15)`;
      ctx.shadowColor = `hsla(${hue}, 100%, 70%, 0.4)`;
      ctx.shadowBlur = 5;
      ctx.lineWidth = 1;

      // Latitudes
      for (let i = 1; i < latLines; i++) {
        const phi = Math.PI * i / latLines;
        const r = radius * Math.sin(phi);
        const z = radius * Math.cos(phi);

        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2 + 0.01; a += 0.1) {
          let [x, y1, z1] = rotate3D(r * Math.cos(a), r * Math.sin(a), z, t * 0.2, t * 0.3);
          const deform = 1 + deformAmount * Math.sin(t + a + phi);
          ctx.lineTo(x * deform, y1 * deform * 0.8 + z1 * 0.1 * deform);
        }
        ctx.stroke();
      }

      // Longitudes
      for (let i = 0; i < lonLines; i++) {
        const theta = Math.PI * 2 * i / lonLines;

        ctx.beginPath();
        for (let j = 0; j <= latLines; j++) {
          const phi = Math.PI * j / latLines;
          let [x, y1, z1] = rotate3D(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi),
            t * 0.2,
            t * 0.3
          );
          const deform = 1 + deformAmount * Math.sin(t + phi + theta);
          ctx.lineTo(x * deform, y1 * deform * 0.8 + z1 * 0.1 * deform);
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    let gegoNodes = [];
    let gegoConnections = [];
    let lastChordSig = '';

    function drawGegoNetModule(t, notes) {
      if (!notes || notes.length === 0) return;

      const chordSig = notes.map(n => n.midi).sort().join('-');
      const velocityAvg = notes.reduce((acc, n) => acc + n.velocity, 0) / notes.length;

      const nodeCount = 5 + notes.length * 15; // más notas = más nodos
      const deformAmount = 2 + velocityAvg * 4; // rebote más sutil
      const scaleFactor = 1 + velocityAvg * 1.2;

      if (chordSig !== lastChordSig) {
        gegoNodes = [];
        gegoConnections = [];

        for (let i = 0; i < nodeCount; i++) {
          gegoNodes.push({
            x: Math.random() * 2 - 1,
            y: Math.random() * 2 - 1,
            z: Math.random() * 0.8 + 0.2,
            offset: Math.random() * 10
          });
        }

        for (let i = 0; i < gegoNodes.length; i++) {
          const connections = [];
          for (let j = 0; j < gegoNodes.length; j++) {
            if (i === j) continue;
            const a = gegoNodes[i];
            const b = gegoNodes[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dz = a.z - b.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            if (dist < 0.7) {
              connections.push({ j, dist });
            }
          }

          // Sort by distance, keep only 3 closest
          connections.sort((a, b) => a.dist - b.dist);
          connections.slice(0, 5).forEach(({ j }) => {
            gegoConnections.push([i, j]);
          });
        }

        lastChordSig = chordSig;
      }

      const angle = t * 0.2;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      ctx.save();
      ctx.translate(width / 2, height / 2);
      ctx.lineWidth = 0.2; // más delgado

      gegoConnections.forEach(([i, j]) => {
        const a = gegoNodes[i];
        const b = gegoNodes[j];

        let ax = a.x * 100;
        let ay = a.y * 100 + Math.sin(t + a.offset) * deformAmount;
        let az = a.z;

        let bx = b.x * 100;
        let by = b.y * 100 + Math.sin(t + b.offset) * deformAmount;
        let bz = b.z;

        const axr = ax * cos - az * sin;
        const azr = ax * sin + az * cos;

        const bxr = bx * cos - bz * sin;
        const bzr = bx * sin + bz * cos;

        const opacity = 0.25 * (2 - azr - bzr);
        ctx.strokeStyle = `hsla(0, 0%, 100%, ${opacity})`;
        ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
        // ctx.shadowBlur = 1;

        ctx.beginPath();
        ctx.moveTo(axr * azr * scaleFactor, ay * azr * scaleFactor);
        ctx.lineTo(bxr * bzr * scaleFactor, by * bzr * scaleFactor);
        ctx.stroke();
      });

      ctx.restore();
    }

    function drawGegoShapeModule(t, notes) {
      if (!notes || notes.length === 0) return;

      const chordSig = notes.map(n => n.midi).sort().join('-');
      const velocityAvg = notes.reduce((a, n) => a + n.velocity, 0) / notes.length;

      const numNodes = 4 + notes.length * 2;
      const deformAmount = 0.1 + velocityAvg * 0.2;
      const baseSize = 240;
      const radius = baseSize * (1 + velocityAvg * 1.0);
      const scale = 1 + velocityAvg * 0.5;

      // Only regenerate if chord changes
      if (chordSig !== lastChordSig) {
        gegoShapeNodes = [];

        for (let i = 0; i < numNodes; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = 1;

          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.sin(phi) * Math.sin(theta);
          const z = r * Math.cos(phi);
          gegoShapeNodes.push({ x, y, z, offset: Math.random() * 10 });
        }

        gegoShapeConnections = [];
        for (let i = 0; i < gegoShapeNodes.length; i++) {
          for (let j = i + 1; j < gegoShapeNodes.length; j++) {
            if (Math.random() < 0.3) {
              gegoShapeConnections.push([i, j]);
            }
          }
        }

        lastChordSig = chordSig;
      }

      const angle = t * 0.2;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      ctx.save();
      ctx.translate(width / 2, height / 2);
      ctx.lineWidth = 0.4;
      ctx.shadowColor = 'rgba(255, 255, 255, 0.1)';
      ctx.shadowBlur = 1;

      gegoShapeConnections.forEach(([i, j]) => {
        const a = gegoShapeNodes[i];
        const b = gegoShapeNodes[j];

        const ax = a.x * cos - a.z * sin;
        const az = a.x * sin + a.z * cos;
        const ay = a.y + Math.sin(t * 0.001 + a.offset) * deformAmount;

        const bx = b.x * cos - b.z * sin;
        const bz = b.x * sin + b.z * cos;
        const by = b.y + Math.sin(t * 0.001 + b.offset) * deformAmount;

        ctx.beginPath();
        ctx.strokeStyle = `hsla(0, 0%, 100%, 0.4)`;
        ctx.moveTo(ax * radius * az * scale, ay * radius * az * scale);
        ctx.lineTo(bx * radius * bz * scale, by * radius * bz * scale);
        ctx.stroke();
      });

      gegoShapeNodes.forEach((node) => {
        const x = node.x * cos - node.z * sin;
        const z = node.x * sin + node.z * cos;
        const y = node.y + Math.sin(t * 0.001 + node.offset) * deformAmount;

        const px = x * radius * z * scale;
        const py = y * radius * z * scale;
        const dotSize = 3 + velocityAvg * 3; // subtle but reactive

        ctx.beginPath();
        ctx.arc(px, py, dotSize, 0, Math.PI * 2);
        ctx.strokeStyle = `hsla(0, 0%, 100%, 0.4)`;
        ctx.lineWidth = 0.5;
        ctx.stroke();
      });

      ctx.restore();
    }

    function checkOverlap(square1, square2) {
      return !(square1.x + square1.size <= square2.x ||
               square1.x >= square2.x + square2.size ||
               square1.y + square1.size <= square2.y ||
               square1.y >= square2.y + square2.size);
    }

    function generateSotoSquares(notes, width, height, existingSquares) {
      const baseSize = 40 * 2; // 2x bigger base
      const squares = [];

      notes.forEach(({ midi, velocity }, idx) => {
        // Only create a new square for a note that hasn't been assigned one yet
        if (!existingSquares.has(midi)) {
          let size = baseSize * (1 + velocity * 3); // up to 6x base
          let x, y;
          let overlap;

          // Try placing the square until it does not overlap with any existing square
          do {
            overlap = false;
            x = Math.random() * (width - size);
            y = Math.random() * (height - size);

            // Check for overlap with all other squares
            for (let existingSquare of existingSquares.values()) {
              if (checkOverlap({ x, y, size }, existingSquare)) {
                overlap = true;
                break; // If overlap, break the loop and retry placement
              }
            }
          } while (overlap);

          const color = SOTO_PALETTE[midi % SOTO_PALETTE.length];
          existingSquares.set(midi, { x, y, size, color });
        }

        // Push the square info from the Map to the squares array
        squares.push(existingSquares.get(midi));
      });

      return squares;
    }

    const existingSquares = new Map();

    function drawSotoGridAnimation(t, notes) {
      if(notes.length === 0) return
      const stripeWidth = 3;
      const stripeCount = Math.ceil(width / stripeWidth);

      const solidHeight = height * 0.2;
      const moireHeight = height - solidHeight;
      const solidY = sotoSolidTop ? 0 : height - solidHeight;

      for (let i = 0; i < stripeCount; i += 2) {
        const x = i * stripeWidth;
        const offset = Math.sin(t * 0.5 + i * 0.2) * 3;

        ctx.beginPath();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = stripeWidth * 0.5;
        ctx.moveTo(x + offset, 0);
        ctx.lineTo(x + offset, height);
        ctx.stroke();
      }

      // 2. Draw solid block (fixed position)
      ctx.fillStyle = '#efe5da';
      ctx.fillRect(0, solidY, width, solidHeight);

      // 3. Draw squares (MIDI rectangles)
      const squares = generateSotoSquares(notes, width, height, existingSquares);
      squares.forEach(({ x, y, size, color }) => {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, size, size);
      });
    }

    function noteOn(channel, midi, velocity) {
      const list = activeNotes[channel];
      if (!list.some(n => n.midi === midi)) {
        list.push({ midi, velocity, timestamp: performance.now() });
      }
    }

    function noteOff(channel, midi) {
      const list = activeNotes[channel];
      const index = list.findIndex(n => n.midi === midi);
      if (index !== -1) list.splice(index, 1);

      // Remove the square for the note when it's turned off
      existingSquares.delete(midi);
    }

    async function setupMIDI() {
      const access = await navigator.requestMIDIAccess();
      for (const input of access.inputs.values()) {
        const name = input.name.toLowerCase();
        let channel = null;
        if (name.includes("bus 1")) channel = "lissajous";
        if (name.includes("bus 2")) channel = "harmonograph";
        if (name.includes("bus 3")) channel = "sphere";
        if (name.includes("bus 4")) channel = "gegoNet";
        if (name.includes("bus 5")) channel = "sinewave";
        if (name.includes("bus 6")) channel = "triangle";
        if (name.includes("bus 7")) channel = "moireCircles";
        if (name.includes("bus 8")) channel = "gegoShape";
        if (name.includes("bus 9")) channel = "sotoGrid";

        if (!channel) continue;

        input.onmidimessage = (msg) => {
          const [status, data1, data2] = msg.data;
          const cmd = status & 0xf0;
          if (cmd === NOTE_ON && data2 > 0) noteOn(channel, data1, data2 / 127);
          if (cmd === NOTE_OFF || (cmd === NOTE_ON && data2 === 0)) noteOff(channel, data1);
        };
      }
    }

    const startButton = document.getElementById('startButton');
    startButton.addEventListener('click', async () => {
      startButton.style.display = 'none';
      await setupMIDI();
      requestAnimationFrame(draw);
    });

    function draw(time) {
      const t = time / 1000;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      drawLissajousComplex(t, activeNotes.lissajous.map(n => n.midi));
      drawHarmonographComplex(t, activeNotes.harmonograph.map(n => n.midi));
      drawWireSphere(t, activeNotes.sphere);
      drawGegoNetModule(t, activeNotes.gegoNet);
      drawNoteVisuals(activeNotes.sinewave, t, 'sinewave', 1.2);
      drawNoteVisuals(activeNotes.triangle, t, 'triangle', 1);
      drawMoirePattern(t, activeNotes.moireCircles);
      drawGegoShapeModule(t, activeNotes.gegoShape);
      drawSotoGridAnimation(t, activeNotes.sotoGrid || []);

      ctx.restore();

      requestAnimationFrame(draw);
    }
  </script>
</body>
</html>
